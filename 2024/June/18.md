6.18

- 책읽기
- 블로그 글 작성하기

팔려고하지말고 사게 만들어라
링크드인에 공유하는 글을 작성하고 조회수가 100명이 넘어갔습니다. 앞으로 더욱더 사게 만들려고 노력해야할 거 같아요.

잘하는 사람이 예시를 들어준다먼 그 역에서 배울게 존재한다. 예시를 만들까지 역을 탐구했을거다.

장점을 부각하기 구시대의 가치라고 폄하하지 말기. 나를 평가하는 사람들은 대부분 나보다 나이가 많은 사람들임

직장을 옮기는 기준이 돈이 되지 않기 내가 맡은 역할에 초점을 두고 표현하기 -> 퇴사 사유를 생각할 때 좋은 재료가 될 거 같음.

1. 글로벌 변수
글로벌 변수는 변경가능한 공유 자원입니다. 어디에서든, 어떤 스레드에서든지 변경할 수 있어요. 데이터 격리가 발생하기 너무나도 좋은 상황입니다.

해결 방법 1. 읽기 가능으로만 만들기 -> let
로거 자체가 sendable이기 때문에 여러 스레드에서 로거를 읽는다고 데이터 격리가 발생하진 않습니다.
해결 방법 2. MainActor에 묶기
모든 로깅이 MainActor에서 호출하게 된다면, 가장 간단하게 해결할 수 있는 접근법입니다.
마지막으로 nonisolated(unsafe)키워드입니다.
데이터가 다른 방식으로 변수를 데이터 격리를 보장할 수도 있습니다. 아마도 Dispatch quque 같이 이런 경우에 complier에게 이 데이터는 안전하다고 알리는 방법이 바로 nonisolated(unsafe)입니다. 단순히 컴파일 에러를 없애고자 사용하게 되면 fatalerror를 만날 수도 있으니 권장하는 방법은 아닙니다.

글로벌 변수를 초기화하는 건 thread safe한가요?
글로벌 변수는 lazy하게 초기화 됩니다. 그렇기 때문에 여러 스레드에서 접근하더라도 하나의 스레드에서만 생성되며, 다른 스레드는 초기화 시키는걸 포기하게 됩니다.

많은 델리게이트와 메인 엑터에서만 작동하도록 설계된 SwiftUI View와 같은 프로토콜은 Xcode 16과 함께 제공되는 sdk에서 @MainActor가 달리게 됩니다.

동시성에서 Call back, completion handler의 경우 해당 콜백의 동시성 보장이 무엇인지 먼저 찾아보셔야합니다. 일부 문서에 모든 콜백이 항상 메인 스레드에 있다고 명시되어 있는 경우도 있습니다.
반면에 일부 델리게이트는 이와 반대로 임의 스레드나 대기열에서 호출되기 때문에 리턴되는 방식을 보장할 수 없습니다. 앱의 백그라운드에서 동작하는 콜백일 수록 이런 가능성이 높습니다. 이런 경우에 올바른 엑터로 재전송하거나 스레드 안전 방식으로 작업을 수행해야합니다. 
하지만 이런 접근은 개발자들이 담당해야하는 부담이 크다는 단점을 갖고 있습니다. 다시 호출 받았을 때, 어디에 있을 것인지, 다음 로직을 수행하기 위해 어디에 있어야하는지 생각해야합니다. 이런 방식의 접근이 아니라면 데이터 경합이 발생할 수 밖에 없을 겁니다. 만약에 콜백이 항상 메인 스레드에 있지 않다고 한다면 추가적으로 해당 코드를 수정해서 더이상 메인 큐로 오지 않는다면 문제가 발생할 수 밖에 없습니다. 지역 추론입니다. 내가 UI 레이어에서 작업할 때 앱의 다른 부분에서 발생하는 코드 변경, 작업 수행하는 큐를 변경하는 등의 이유로 쉽게 깨지지 않는다는 보장을 뜻합니다.

"하지만 UI 레이어는 그것이 메인 큐에 있는 것에 의존하고 있었습니다. 여기서 우리가 놓치고 있는 것은 지역적 추론(local reasoning)입니다. 즉, 내가 UI 레이어에서 작업할 때 앱의 다른 부분에서 발생하는 코드 변경, 예를 들어 그들이 작업을 수행하는 큐를 변경하는 등의 이유로 쉽게 깨지지 않는다는 보장을 말합니다."

Swift 동시성은 이러한 보장 또는 보장 부족을 명시함으로써 이 문제를 해결하고자 합니다. 콜백이 호출되는 방식에 대해서 명시하지 않으면, non-isolated로 고려되며 그리고 특정 격리가 필요한 데이터에 엑세스 할 수 없습니다. 반면 콜백이 항상 메인 엑터에서 다시 호출된다는 격리 보장을 제공할 경우, 델리게이트 프로토콜 , 콜백은 메인엑터에 있다고 주석을 달 수 있으며 수신자는 보장을 신뢰할 수 있게 됩니다.

메인 엑터의 델리게이트 유형이 비격리 프로토콜을 준수할 수 없다는 첫번 째 경고로 가보겟습니다.
해결방법 1. 메소드를 nonisolated로 선언하는 거
이건 메소드가 격리된 메인 엑터에서 실행됨에도, 해당 메소드는 메인엑터로 부터 격리되지 못했습니다.

의도적으로 어디로 다시 호출할지 약속되지 않는 콜백의 경우 해당 방식을 사용해야합니다.
물론 이건 뷰이기 때문에 MainActor를 작성하면 되지만 그렇게 하지 않으면 메인 엑터에 의해 보호되는 뷰의 프로퍼티에 엑세스하기 때문에 새로운 오류가 발생합니다.

Assumeisloated를 사용해서, 처리할 수 있음.
그치만 해당 정보에 대해서 알 수 없지만, 채택한 객체가 @MainActor에서 실행된다고 생각했을 때, MainActor.assumtion { }을 호출하면 된다.
메인 엑터에 비동기화할 새 작업이 실행되는게 아닌, 이미 메인 엑터에서 실행중이라고 swift에게 알리는 방법이다.
단. MainActor에서 실질적으로 호출되지 않으면 fatalError가 발생
사용자 데이터를 손상시킬 수 있는 경쟁 조건보단, Trap되는게 올바른 선택.

@preconcurrency를 붙이면 메인 엑터에서 호출된다고 가정하고 그러지 않을 경우 트래핑됩니다.

Data isolation에 대해서 얘기하기,
@preconcurrency에 대한 내용을 간략하게 설명하고 따로 글로 빼기

/// Swift 6.0에서는 NSCopying으로 보내는 값은 컴파일 에러가 나지 않도록 됨. 5.10에서는 그냥 전부 차단했었음.
엑터간 메세지로 레퍼런스를 전달하고 메인 엑터에서 그 값을 사용하지 않으면 문제가 발생하지 않음. 하지만 메세지 전달을 하고 나서 접근하게 되면 컴파일 에러가 생김

인터널의 경우, 타입 전체가 센더블이면 자동 추론하지만 public일 경우에는 자동 추론이 비활성화 됩니다. 공개되지 않는 속성중에 non-sendable이 존재할 수 있을수도 있기 때문입니다.

마지막으로 드리고 싶은 말은 모든 상황에 대해서 swift concurrency로 해결할 수 없습니다. Mutable state를 모든 actor에서 핸들링할 수 없을 수 있으며, Task를 관리하는 방식도 기존과 다르게 제어를 역전시킬 수도 있습니다. 이런 모든 컨셉을 낮은 버전 os에선 구현하기는 불가능하다고 생각합니다. 모든 코드를 Swift Concurrency로 변경하려고 노력하는 것 보단, 기본 틀은 동시성으로 구현하지만 필요에 의해서 다른 프레임워크를 동시성으로 컨버팅하는 스킬도 같이 키우시면 좋을 거 같습니다 :)


