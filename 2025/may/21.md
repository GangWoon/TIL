5.21
값 타입 vs 참조 타입

값 타입과 참조 타입의 본질적인 차이는 메모리 구조와 데이터 전달 방식에 있습니다.
복사가 발생할 때, 값 타입은 스택 또는 힙에 저장된 데이터를 복사해서 전달하며, 각 인스턴스가 서로 독립적입니다.
반면 참조 타입은 힙 영역에 저장된 데이터의 참조로 전달하므로, 여러 인스턴스가 같은 객체를 공유하게 됩니다.

Swift는 기본적으로 값을 복사하여 전달하는 값 의미론을 따르기 때문에
동일한 데이터를 여러 곳에서 다룰 때 복사 비용이 발생할 수 있습니다.
이를 보완하기 위해, Array, String 등 일부 값 타입은(크기를 예측할 수 없는 데이터의 경우)
Copy on Write 전략을 사용하여, 읽을 때는 참조를 공유하고, 수정이 발생하는 시점에만 복사가 일어나도록 설계되어 있습니다.

동시성 관점에서는 값 타입은 데이터를 복사해서 사용하기 때문에 스레드 안전성이 확보되고,
참조 타입은 여러 스레드에서 동일한 인스턴스를 접근할 수 있으므로 추가적인 동기화가 필요합니다.

값 타입의 경우 데이터를 담는 컨테이너 처럼 사용하는 경우가 많고, 참조 타입은 데이터 뿐만아니라 데이터를 중심으로 한 행동까지 담을 필요가 있을 경우 사용합니다.

ARC(Automatic Reference Counting)
ARC는 Swift에서 참조 타입 인스턴스의 메모리를 자동으로 관리하는 방식입니다.
인스턴스를 참조하는 카운트가 0이 되면 자동으로 메모리가 해제됩니다.

ARC에서 사용할 수 있는 참조 방식은 strong, weak, 그리고 unowned입니다.

가장 기본이 되는 strong은 참조 카운트를 증가시키는 방식이고,
해당 참조가 남아 있는 동안은 메모리가 해제되지 않습니다.

반면 weak은 참조 카운트를 증가시키지 않기 때문에, 순환 참조를 방지할 수 있습니다.
대신 인스턴스가 해제되면 자동으로 nil로 바뀌기 때문에, weak으로 선언된 변수는 반드시 Optional 타입이어야만 합니다.

unowned는 weak처럼 카운트를 증가시키진 않지만, Optional이 아닙니다. 
값이 해제된 상태에서 접근하면 런타임 크래시, 즉 dangling pointer 문제가 발생합니다.
그래서 보통  객체간 관계가 명확할 때 사용해야만 합니다. 

@TaskLocal

비동기 작업간에 로컬한 값을 안전하게 전달할 수 있도록 돕는 기능.
스레드-로컬 변수라고 생각할 수도 있음.

비동기 컨텍스트에서 전달되는 값이기 때문에 Sendable이여야하며, 구조적 동시성을 사용할 경우, 값이 상속됨.

가장 큰 장점은 작업 단위로 값이 격리된다는 점과 암묵적 전달이 가능하다는 점이다.
값이 격리되기 때문에 다른 환경으로 유연하게 설정이 가능해진다. 그걸 활용하는 대표적인 예시가 SwiftUI.Enviornment이다.

enum Hello {
  @TaskLocal static var count = 0
}

Hello.$count.withValue(3) {
  Hello.count // 3
  
  Task {
    Hello.count // 3
  }
  
  Task.detached {
    Hello.count // 0
  }
}

Hello.count // 0


sending annotation
Sendable과 다르게 Non-Sendable 타입을 안전하게 다른 동시성 컨텍스트로 전달할 수 있도록 도와줍니다.

Non-Sendable이지만 동시성 환경에서도 안전하게 전달이 가능한 이유는, 해당 값의 소유권을 이전시키기 때문입니다.
이를 통해 더 이상 해당 값에 접근하지 못하게 하여 데이터 레이스를 방지하게 돕니다.

Task 이니셜라이저와, Continuation이 Sendable Type만 받던거에서 sending Value를 받도록 수정된게 가장 큰 변화 중 하나입니다.

기존에 컴파일 에러가 발생하지 않던 부분들에서 컴파일 에러가 발생할 수 있다는 점이 가장 큰 문제로 느껴질겁니다.
